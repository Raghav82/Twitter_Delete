
/**
 * X (Twitter) Mass Delete â€“ UI Automation (No tokens required)
 * ------------------------------------------------------------
 * Patched to respect backend rate limits and reduce burstiness.
 *
 * Rate limit context (applies even via web UI):
 * - DELETE posts is ~50 requests per 15 minutes per user, and ~300 per 3 hours. [1]
 * - When exceeded, backend returns 429 Too Many Requests; UI actions silently fail. [2]
 * [1] https://docs.x.com/x-api/posts/manage-tweets/introduction
 * [2] https://docs.x.com/x-api/fundamentals/response-codes-and-errors
 */

//////////////////////////////
// Tunable pacing & backoff //
//////////////////////////////

const CLICK_DELAY_MS_BASE  = 2000;  // after clicks
const SCROLL_DELAY_MS_BASE = 2400;  // after scroll
const SHORT_PAUSE_MS_BASE  = 800;   // spacing between tweets
const JITTER_MAX_MS        = 500;   // random jitter added

const MAX_RETRIES          = 2;

const SOFT_CAP_PER_WINDOW  = 45;                // ~50/15-min
const WINDOW_RESET_MS      = 15 * 60 * 1000;    // 15 minutes

const LONG_CAP_PER_3H      = 290;               // ~300/3h
const LONG_RESET_MS        = 3 * 60 * 60 * 1000; // 3 hours

const FAILURE_STREAK_LIMIT = 7;
const FAILURE_COOLDOWN_MS  = 15 * 60 * 1000;    // 15 minutes

/////////////////////
// Progress & state //
/////////////////////

let totalDeleted = 0;
let totalUndoneReposts = 0;
let totalThisWindow = 0;
let totalThis3H = 0;
let failureStreak = 0;

////////////////////////
// Utility & helpers  //
////////////////////////

const sleep = (ms) => new Promise(r => setTimeout(r, ms));
const jitter = (base) => base + Math.floor(Math.random() * JITTER_MAX_MS);

const waitFor = async (selector, timeout = 8000) => {
  const start = performance.now();
  while (performance.now() - start < timeout) {
    const el = document.querySelector(selector);
    if (el) return el;
    await sleep(100);
  }
  return null;
};

const clickIfExists = async (el) => {
  if (!el) return false;
  el.click();
  await sleep(jitter(CLICK_DELAY_MS_BASE));
  return true;
};

const maybeWindowPause = async () => {
  if (totalThisWindow >= SOFT_CAP_PER_WINDOW) {
    console.log(`â¸ï¸ Soft cap reached (${totalThisWindow}). Pausing 15 minutesâ€¦`);
    await sleep(WINDOW_RESET_MS);
    totalThisWindow = 0;
  }
};

const maybeLongPause = async () => {
  if (totalThis3H >= LONG_CAP_PER_3H) {
    console.log(`â¸ï¸ Long cap reached (~${totalThis3H}). Pausing 3 hoursâ€¦`);
    await sleep(LONG_RESET_MS);
    totalThis3H = 0;
  }
};

const handleSuccess = async () => {
  failureStreak = 0;
  totalThisWindow++;
  totalThis3H++;
  await maybeWindowPause();
  await maybeLongPause();
};

const handleFailure = async () => {
  failureStreak++;
  if (failureStreak >= FAILURE_STREAK_LIMIT) {
    console.log(`â¸ï¸ Multiple failures (${failureStreak}). Cooling off 15 minutesâ€¦`);
    await sleep(FAILURE_COOLDOWN_MS);
    failureStreak = 0;
    totalThisWindow = 0;
  } else {
    await sleep(jitter(1500));
  }
};

//////////////////////////
// DOM accessor helpers //
//////////////////////////

const findMenuButton = (tweetCard) =>
  tweetCard.querySelector('[data-testid="caret"], [aria-label="More"]');

const findDeleteButton = () =>
  Array.from(document.querySelectorAll('span'))
    .find(s => s.textContent.trim().toLowerCase() === 'delete');

const findUndoRepostButton = () => {
  const variants = ['Undo repost', 'Undo Repost', 'Remove repost', 'Remove Retweet', 'Undo Retweet'];
  return Array.from(document.querySelectorAll('span'))
    .find(s => variants.includes(s.textContent.trim()));
};

const findConfirmDelete = () =>
  document.querySelector('[data-testid="confirmationSheetConfirm"], [data-testid="confirmationSheetConfirm"] [role="button"]');

const isAuthoredByProfile = (tweetCard) => {
  const handle = (location.pathname.split('/')[1] || '').toLowerCase();
  if (!handle) return true;

  const link = Array.from(tweetCard.querySelectorAll('a[href*="/status/"]'))
    .find(a => /\/status\/\d+/.test(a.href));
  if (!link) return true;

  try {
    const url = new URL(link.href);
    const author = (url.pathname.split('/')[1] || '').toLowerCase();
    return author === handle;
  } catch {
    return true;
  }
};

//////////////////////////////////////
// Per-tweet processing routine     //
//////////////////////////////////////

const processTweet = async (tweetCard) => {
  if (!isAuthoredByProfile(tweetCard)) return false;

  // 1) Open menu
  let opened = false;
  for (let i = 0; i < MAX_RETRIES; i++) {
    const menuBtn = findMenuButton(tweetCard);
    if (await clickIfExists(menuBtn)) { opened = true; break; }
    await sleep(jitter(CLICK_DELAY_MS_BASE));
  }
  if (!opened) { await handleFailure(); return false; }

  // 2) Try delete
  let btn = findDeleteButton();
  if (btn) {
    btn.click();
    await sleep(jitter(CLICK_DELAY_MS_BASE));

    const confirm = await waitFor('[data-testid="confirmationSheetConfirm"]', 6000);
    if (confirm) {
      confirm.click();
      totalDeleted++;
      console.log(`ðŸ—‘ï¸ Deleted post. Deleted=${totalDeleted}`);
      await sleep(jitter(CLICK_DELAY_MS_BASE));
      await handleSuccess();
      return true;
    } else {
      await handleFailure();
      return false;
    }
  }

  // 3) Try undo repost
  btn = findUndoRepostButton();
  if (btn) {
    btn.click();
    await sleep(jitter(CLICK_DELAY_MS_BASE));

    const confirm = findConfirmDelete();
    if (confirm) confirm.click();

    totalUndoneReposts++;
    console.log(`ðŸ” Undid repost. Undone=${totalUndoneReposts}`);
    await sleep(jitter(CLICK_DELAY_MS_BASE));
    await handleSuccess();
    return true;
  }

  await handleFailure();
  return false;
};

//////////////////////////////////////
// Main loop: iterate â†’ scroll â†’ repeat
//////////////////////////////////////

const run = async () => {
  console.log('Starting deletionâ€¦ Delays use jitter to reduce burstiness.');

  while (true) {
    const tweets = Array.from(document.querySelectorAll('article[data-testid="tweet"]'));

    if (tweets.length === 0) {
      window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
      await sleep(jitter(SCROLL_DELAY_MS_BASE));
    }

    let processedInPass = 0;

    for (const card of tweets) {
      const didSomething = await processTweet(card);
      if (didSomething) processedInPass++;
      await sleep(jitter(SHORT_PAUSE_MS_BASE));
    }

    if (processedInPass === 0) {
      window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
      await sleep(jitter(SCROLL_DELAY_MS_BASE));
      const moreTweets = document.querySelectorAll('article[data-testid="tweet"]');
      if (moreTweets.length === 0) break;
    }
  }

  console.log(`âœ… Finished. Deleted=${totalDeleted}, UndidReposts=${totalUndoneReposts}`);
};

run();
